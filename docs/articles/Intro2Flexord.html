<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Introduction to Flexible Clustering of (Mixed-With-)Ordinal Data • flexord</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Introduction to Flexible Clustering of (Mixed-With-)Ordinal Data">
<meta property="og:description" content="flexord">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">flexord</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.0.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/Intro2Flexord.html">Introduction to Flexible Clustering of (Mixed-With-)Ordinal Data</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/dernst/flexord/" class="external-link">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Introduction to Flexible Clustering of
(Mixed-With-)Ordinal Data</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/dernst/flexord/blob/HEAD/../vignettes/Intro2Flexord.Rmd" class="external-link"><code>../vignettes/Intro2Flexord.Rmd</code></a></small>
      <div class="hidden name"><code>Intro2Flexord.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="package-description-and-contents">Package description and contents<a class="anchor" aria-label="anchor" href="#package-description-and-contents"></a>
</h2>
<p>Package <strong>flexord</strong> is an add on-package to packages
<strong>flexclust</strong> and <strong>flexmix</strong> that provide
suites for partitioning and model-based clustering with flexible method
switching and comparison.</p>
<p>We provide additional distance and centroid calculation functions,
and additional model drivers for component distributions that are
tailored towards ordinal, or mixed-with-ordinal data. These new methods
can easily be plugged into the capabilities for clustering provided by
<strong>flexclust</strong> and <strong>flexmix</strong>.</p>
<p>By plugging them into the <em>flex-scheme</em>, they can be used
for:</p>
<ul>
<li>one-off K-centroids and model-based clustering (via
<code><a href="https://rdrr.io/pkg/flexclust/man/kcca.html" class="external-link">flexclust::kcca</a></code> and <code><a href="https://rdrr.io/pkg/flexmix/man/flexmix.html" class="external-link">flexmix::flexmix</a></code>),</li>
<li>repeated clustering runs with various cluster numbers <code>k</code>
(via <code><a href="https://rdrr.io/pkg/flexclust/man/stepFlexclust.html" class="external-link">flexclust::stepFlexclust</a></code> and
<code><a href="https://rdrr.io/pkg/flexmix/man/stepFlexmix.html" class="external-link">flexmix::stepFlexmix</a></code>),</li>
<li>bootstrapping repeated clustering runs with various cluster numbers
<code>k</code> for K-centroids clustering (via
<code><a href="https://rdrr.io/pkg/flexclust/man/bootFlexclust.html" class="external-link">flexclust::bootFlexclust</a></code>),</li>
<li>applying the various methods for the resulting objects, such as
<code>predict</code>, <code>plot</code>, <code>barchart</code>, …</li>
</ul>
The new methods provided are:
<table class="table">
<thead><tr>
<th style="text-align:left;">
Clustering Type
</th>
<th style="text-align:left;">
Function Type
</th>
<th style="text-align:left;">
Function Name
</th>
<th style="text-align:left;">
Method
</th>
<th style="text-align:left;">
Scale Assumptions
</th>
<th style="text-align:left;">
NA Handling
</th>
<th style="text-align:left;">
Source
</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align:left;">
Partitioning (K-centroids)
</td>
<td style="text-align:left;">
distance
</td>
<td style="text-align:left;">
<code>distSimMatch</code>
</td>
<td style="text-align:left;">
Simple Matching Distance
</td>
<td style="text-align:left;">
nominal
</td>
<td style="text-align:left;">
not implemented
</td>
<td style="text-align:left;">
<span class="citation">Kaufman and Rousseeuw (1990)</span>, p. 19
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
<code>distGDM2</code>
</td>
<td style="text-align:left;">
GDM2 distance for ordinal data
</td>
<td style="text-align:left;">
ordinal
</td>
<td style="text-align:left;">
not implemented
</td>
<td style="text-align:left;">
<span class="citation">Walesiak and Dudek (2010)</span>; <span class="citation">Ernst et al. (2025)</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
<code>distGower</code>
</td>
<td style="text-align:left;">
Gower’s distance
</td>
<td style="text-align:left;">
mixed-with-ordinal
</td>
<td style="text-align:left;">
upweighing of present variables
</td>
<td style="text-align:left;">
<span class="citation">Kaufman and Rousseeuw (1990)</span>, p. 32-37
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
centroid
</td>
<td style="text-align:left;">
<code>centMode</code>
</td>
<td style="text-align:left;">
Mode as centroid
</td>
<td style="text-align:left;">
nominal
</td>
<td style="text-align:left;">
not implemented
</td>
<td style="text-align:left;">
<span class="citation">Weihs et al. (2005)</span>; <span class="citation">Leisch (2006)</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
<code>centMin</code>
</td>
<td style="text-align:left;">
Factor level with minimal distance as centroid
</td>
<td style="text-align:left;">
nominal/ordinal
</td>
<td style="text-align:left;">
not implemented
</td>
<td style="text-align:left;">
<span class="citation">Ernst et al. (2025)</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
<code>centOptimNA</code>
</td>
<td style="text-align:left;">
Centroid calculation by general purpose optimizer
</td>
<td style="text-align:left;">
numeric
</td>
<td style="text-align:left;">
complete-case analysis
</td>
<td style="text-align:left;">
<span class="citation">Leisch (2006)</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
wrapper
</td>
<td style="text-align:left;">
<code>kccaExtendedFamily</code>
</td>
<td style="text-align:left;">
Creates a <code>kccaFamily</code> object pre-configured for kModes-,
kGDM2- or kGower clustering
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
</tr>
<tr>
<td style="text-align:left;">
Model-based
</td>
<td style="text-align:left;">
driver
</td>
<td style="text-align:left;">
<code>FLXMCregnorm</code>
</td>
<td style="text-align:left;">
Regularized multivariate normal distribution
</td>
<td style="text-align:left;">
numeric
</td>
<td style="text-align:left;">
not implemented
</td>
<td style="text-align:left;">
<span class="citation">Fraley and Raftery (2007)</span>; <span class="citation">Ernst et al. (2025)</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
<code>FLXMCregmultinom</code>
</td>
<td style="text-align:left;">
Regularized multivariate multinomial distribution
</td>
<td style="text-align:left;">
nominal
</td>
<td style="text-align:left;">
not implemented
</td>
<td style="text-align:left;">
<span class="citation">Galindo Garre and Vermunt (2006)</span>; <span class="citation">Ernst et al. (2025)</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
<code>FLXMCregbinom</code>
</td>
<td style="text-align:left;">
Regularized multivariate binomial distribution
</td>
<td style="text-align:left;">
ordinal
</td>
<td style="text-align:left;">
not implemented
</td>
<td style="text-align:left;">
<span class="citation">Ernst et al. (2025)</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
</td>
<td style="text-align:left;">
<code>FLXMCbetabinomial</code>
</td>
<td style="text-align:left;">
Regularized multivariate beta-binomial distribution
</td>
<td style="text-align:left;">
ordinal
</td>
<td style="text-align:left;">
not implemented
</td>
<td style="text-align:left;">
<span class="citation">Kondofersky (2008)</span>; <span class="citation">Ernst et al. (2025)</span>
</td>
</tr>
</tbody>
</table>
</div>
<div class="section level2">
<h2 id="example-1-clustering-purely-nominal-data">Example 1: Clustering purely nominal data<a class="anchor" aria-label="anchor" href="#example-1-clustering-purely-nominal-data"></a>
</h2>
<p>We load necessary packages and set a random seed for
reproducibility.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st"><a href="https://github.com/dernst/flexord" class="external-link">"flexord"</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st">"flexclust"</span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="st">"flexmix"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1111</span><span class="op">)</span></span></code></pre></div>
<p>As an example for purely nominal data, we will use the classic
<code>Titanic</code> data set:</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">titanic_df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">Titanic</span><span class="op">)</span></span>
<span><span class="va">titanic_df</span> <span class="op">&lt;-</span> <span class="va">titanic_df</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">titanic_df</span><span class="op">)</span>, <span class="va">titanic_df</span><span class="op">$</span><span class="va">Freq</span><span class="op">)</span>, <span class="op">-</span><span class="fl">5</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html" class="external-link">str</a></span><span class="op">(</span><span class="va">titanic_df</span><span class="op">)</span></span>
<span><span class="co">#&gt; 'data.frame':    2201 obs. of  4 variables:</span></span>
<span><span class="co">#&gt;  $ Class   : Factor w/ 4 levels "1st","2nd","3rd",..: 3 3 3 3 3 3 3 3 3 3 ...</span></span>
<span><span class="co">#&gt;  $ Sex     : Factor w/ 2 levels "Male","Female": 1 1 1 1 1 1 1 1 1 1 ...</span></span>
<span><span class="co">#&gt;  $ Age     : Factor w/ 2 levels "Child","Adult": 1 1 1 1 1 1 1 1 1 1 ...</span></span>
<span><span class="co">#&gt;  $ Survived: Factor w/ 2 levels "No","Yes": 1 1 1 1 1 1 1 1 1 1 ...</span></span></code></pre></div>
<div class="section level3">
<h3 id="partitioning-approach">Partitioning approach<a class="anchor" aria-label="anchor" href="#partitioning-approach"></a>
</h3>
<p>We can conduct K-centroids clustering with the kModes algorithm
directly on the data frame<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/flexclust/man/kcca.html" class="external-link">kcca</a></span><span class="op">(</span><span class="va">titanic_df</span>, k <span class="op">=</span> <span class="fl">4</span>, family <span class="op">=</span> <span class="fu"><a href="../reference/kccaExtendedFamily.html">kccaExtendedFamily</a></span><span class="op">(</span><span class="st">'kModes'</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; kcca object of family 'kModes' </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; call:</span></span>
<span><span class="co">#&gt; kcca(x = titanic_df, k = 4, family = kccaExtendedFamily("kModes"))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; cluster sizes:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;    1    2    3    4 </span></span>
<span><span class="co">#&gt;  140  396  287 1378</span></span></code></pre></div>
<p>Let us assume that for some reason we are unhappy with the mode as a
centroid, and rather want to use an optimized centroid value, by
choosing the factor level for which Simple Matching distance<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> is
minimal:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/flexclust/man/kcca.html" class="external-link">kcca</a></span><span class="op">(</span><span class="va">titanic_df</span>, k <span class="op">=</span> <span class="fl">4</span>,</span>
<span>     family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/flexclust/man/kcca.html" class="external-link">kccaFamily</a></span><span class="op">(</span>dist <span class="op">=</span> <span class="va">distSimMatch</span>, </span>
<span>                         cent <span class="op">=</span> \<span class="op">(</span><span class="va">y</span><span class="op">)</span> <span class="fu"><a href="../reference/centroids.html">centMin</a></span><span class="op">(</span><span class="va">y</span>, dist <span class="op">=</span> <span class="va">distSimMatch</span>,</span>
<span>                                             xrange <span class="op">=</span> <span class="st">'columnwise'</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; kcca object of family 'distSimMatch' </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; call:</span></span>
<span><span class="co">#&gt; kcca(x = titanic_df, k = 4, family = kccaFamily(dist = distSimMatch, </span></span>
<span><span class="co">#&gt;     cent = function(y) centMin(y, dist = distSimMatch, xrange = "columnwise")))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; cluster sizes:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   1   2   3   4 </span></span>
<span><span class="co">#&gt; 369 737 317 778</span></span></code></pre></div>
<p>This already showcases one of the advantages of package
<strong>flexclust</strong>: As the name suggests, we are quickly able to
mix and match our distance and centroid functions, and quickly create
our own K-centroids algorithms.</p>
<p>Furthermore, <strong>flexclust</strong> allows us to decrease the
influence of randomness via running the algorithm several times, and
keeping only the solution with the minimum within cluster distance. This
can be done for one specific number of clusters <code>k</code> or
several values <code>k</code>:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">titanic_dm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.matrix.html" class="external-link">data.matrix</a></span><span class="op">(</span><span class="va">titanic_df</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/flexclust/man/stepFlexclust.html" class="external-link">stepFlexclust</a></span><span class="op">(</span><span class="va">titanic_dm</span>, k <span class="op">=</span> <span class="fl">2</span><span class="op">:</span><span class="fl">4</span>, nrep <span class="op">=</span> <span class="fl">3</span>, </span>
<span>              family <span class="op">=</span> <span class="fu"><a href="../reference/kccaExtendedFamily.html">kccaExtendedFamily</a></span><span class="op">(</span><span class="st">'kModes'</span><span class="op">)</span><span class="op">)</span> </span>
<span><span class="co">#&gt; 2 : * * *</span></span>
<span><span class="co">#&gt; 3 : * * *</span></span>
<span><span class="co">#&gt; 4 : * * *</span></span>
<span><span class="co">#&gt; stepFlexclust object of family 'kModes' </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; call:</span></span>
<span><span class="co">#&gt; stepFlexclust(x = titanic_dm, k = 2:4, nrep = 3, family = kccaExtendedFamily("kModes"))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   iter converged distsum</span></span>
<span><span class="co">#&gt; 1   NA        NA  651.50</span></span>
<span><span class="co">#&gt; 2  200     FALSE  413.50</span></span>
<span><span class="co">#&gt; 3  200     FALSE  278.75</span></span>
<span><span class="co">#&gt; 4  200     FALSE  246.00</span></span></code></pre></div>
<p>The output above shows the solutions with lowest within cluster
distance out of 3 runs for 2 to 4 clusters, in comparison to 1 big
cluster. However, none of the algorithms converged. Presumably this is
due to observations which have the same distance to two centroids and
which are randomly assigned to one of the two centroids, implying that
the partitions are still changing in each iteration, even if the
centroids do not change.</p>
<p>Selecting a suitable number of clusters based on the output of
<code>stepFlexclust</code> might be still difficult. This is where
<code>bootFlexclust</code> comes in. In <code>bootFlexclust</code>,
<code>nboot</code> bootstrap samples of the original data are drawn, on
which <code>stepFlexclust</code> is performed for each <code>k</code>.
This results in <code>k</code><span class="math inline">\(\times\)</span><code>nboot</code> best out of
<code>nrep</code> clustering solutions obtained for each bootstrap data
set. Based on these solutions cluster memberships are predicted for the
original data set, and the stability of these partitions is tested via
the Adjusted Rand Index <span class="citation">(Hubert and Arabie
1985)</span>:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span><span class="va">nom</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/flexclust/man/bootFlexclust.html" class="external-link">bootFlexclust</a></span><span class="op">(</span><span class="va">titanic_dm</span>, k <span class="op">=</span> <span class="fl">2</span><span class="op">:</span><span class="fl">4</span>, nrep <span class="op">=</span> <span class="fl">3</span>, nboot <span class="op">=</span> <span class="fl">5</span>, </span>
<span>                      family <span class="op">=</span> <span class="fu"><a href="../reference/kccaExtendedFamily.html">kccaExtendedFamily</a></span><span class="op">(</span><span class="st">'kModes'</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; An object of class 'bootFlexclust' </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; bootFlexclust(x = titanic_dm, k = 2:4, nboot = 5, nrep = 3, family = kccaExtendedFamily("kModes"))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Number of bootstrap pairs: 5</span></span></code></pre></div>
<p>Note that ridiculously few repetitions are used for the sake of
having a short run time. Clearly <code>nboot</code> should be increased
in applications.</p>
<p>The resulting ARIs can be quickly visualized via a predefined
plotting method:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">nom</span><span class="op">)</span></span></code></pre></div>
<p><img src="Intro2Flexord_files/figure-html/nominal_p6-1.png" width="60%"></p>
<p>Our plot indicates that out of the 2 to 4 cluster solutions, a three
cluster solution has the highest median ARI out of 5 runs.</p>
<p>Now, after deciding on a suitable number of clusters, we could select
the corresponding cluster solution from <code>kcca</code> or
<code>stepFlexclust</code>, and make use of the further visualization,
prediction, and other tools. For this, we refer to the documentation
available in <span class="citation">Leisch (2006)</span> and <span class="citation">Dolnicar, Grün, and Leisch (2018)</span>.</p>
</div>
<div class="section level3">
<h3 id="model-based-approach">Model-based approach<a class="anchor" aria-label="anchor" href="#model-based-approach"></a>
</h3>
<p>We also offer an algorithm specifically designed for model-based
clustering of unordered categorical data via a regularized multinomial
distribution. The multinomial driver also supports varying number of
categories between variables. We call <strong>flexmix</strong> using the
model driver <code><a href="../reference/FLXMCregmultinom.html">FLXMCregmultinom()</a></code> where we specify via the
argument <code>r</code> the number of categories for each variable:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">titanic_ncats</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">titanic_dm</span>, <span class="fl">2</span>, <span class="va">max</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/flexmix/man/flexmix.html" class="external-link">flexmix</a></span><span class="op">(</span>formula <span class="op">=</span> <span class="va">titanic_dm</span> <span class="op">~</span> <span class="fl">1</span>, k <span class="op">=</span> <span class="fl">3</span>,</span>
<span>        model <span class="op">=</span> <span class="fu"><a href="../reference/FLXMCregmultinom.html">FLXMCregmultinom</a></span><span class="op">(</span>r <span class="op">=</span> <span class="va">titanic_ncats</span><span class="op">)</span><span class="op">)</span> </span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; flexmix(formula = titanic_dm ~ 1, k = 3, model = FLXMCregmultinom(r = titanic_ncats))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Cluster sizes:</span></span>
<span><span class="co">#&gt;    1    2    3 </span></span>
<span><span class="co">#&gt; 1208  364  629 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; convergence after 125 iterations</span></span></code></pre></div>
<p>As we are estimating many category probabilities across multiple
clusters, some of those may become numerically zero, resulting in a
degenerate distribution. To avoid this we may use the regularization
parameter <span class="math inline">\(\alpha\)</span>, which acts if we
added <span class="math inline">\(\alpha\)</span> observations according
to the population mean to each component:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/flexmix/man/flexmix.html" class="external-link">flexmix</a></span><span class="op">(</span><span class="va">titanic_dm</span> <span class="op">~</span> <span class="fl">1</span>, k <span class="op">=</span> <span class="fl">3</span>,</span>
<span>        model <span class="op">=</span> <span class="fu"><a href="../reference/FLXMCregmultinom.html">FLXMCregmultinom</a></span><span class="op">(</span>r <span class="op">=</span> <span class="va">titanic_ncats</span>, alpha <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; flexmix(formula = titanic_dm ~ 1, k = 3, model = FLXMCregmultinom(r = titanic_ncats, </span></span>
<span><span class="co">#&gt;     alpha = 1))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Cluster sizes:</span></span>
<span><span class="co">#&gt;    1    2    3 </span></span>
<span><span class="co">#&gt;  364  629 1208 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; convergence after 56 iterations</span></span></code></pre></div>
<p><strong>flexmix</strong> also provides function
<code><a href="https://rdrr.io/pkg/flexmix/man/stepFlexmix.html" class="external-link">stepFlexmix()</a></code>, where the EM algorithm for each
<code>k</code> is restarted <code>nrep</code> times, and only the
maximum likelihood solution is retained:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span><span class="va">nom</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/flexmix/man/stepFlexmix.html" class="external-link">stepFlexmix</a></span><span class="op">(</span><span class="va">titanic_dm</span> <span class="op">~</span> <span class="fl">1</span>, k <span class="op">=</span> <span class="fl">2</span><span class="op">:</span><span class="fl">4</span>,</span>
<span>                    nrep <span class="op">=</span> <span class="fl">3</span>, <span class="co"># please increase for real-life use</span></span>
<span>                    model <span class="op">=</span> <span class="fu"><a href="../reference/FLXMCregmultinom.html">FLXMCregmultinom</a></span><span class="op">(</span>r <span class="op">=</span> <span class="va">titanic_ncats</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; 2 : * * *</span></span>
<span><span class="co">#&gt; 3 : * * *</span></span>
<span><span class="co">#&gt; 4 : * * *</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; stepFlexmix(titanic_dm ~ 1, model = FLXMCregmultinom(r = titanic_ncats), </span></span>
<span><span class="co">#&gt;     k = 2:4, nrep = 3)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   iter converged k k0    logLik      AIC      BIC      ICL</span></span>
<span><span class="co">#&gt; 2   38      TRUE 2  2 -5327.340 10680.68 10754.74 10986.90</span></span>
<span><span class="co">#&gt; 3  103      TRUE 3  3 -5202.816 10445.63 10559.57 11036.09</span></span>
<span><span class="co">#&gt; 4  121      TRUE 4  4 -5176.038 10406.08 10559.89 11454.98</span></span></code></pre></div>
<p>The output provides an overview on the best solutions out of three EM
runs for 3 different values of <code>k</code>. For each solution, it is
indicated how many iterations of the EM algorithm were performed
(<code>iter</code>), if the EM algorithm converged
(<code>converged</code>), the number of components in the final solution
(<code>k</code>) and the number of components the EM algorithm was
initialized with (<code>k0</code>) as well as the maximum log-likelihood
(<code>logLik</code>) and results for different model selection
criteria, namely, AIC, BIC and ICL.</p>
<p>Similar to package <strong>flexclust</strong> in the partitioning
case, package <strong>flexmix</strong> also offers various plotting
methods for the returned objects. We just showcase here one:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">nom</span><span class="op">)</span></span></code></pre></div>
<p><img src="Intro2Flexord_files/figure-html/nominal_m5-1.png" width="60%"></p>
<p>For more information on the further methods and utilities offered,
check out the documentation for <strong>flexmix</strong> (see for
example <code>browseVignettes('flexmix')</code>).</p>
</div>
</div>
<div class="section level2">
<h2 id="example-2-clustering-purely-ordinal-data">Example 2: Clustering purely ordinal data<a class="anchor" aria-label="anchor" href="#example-2-clustering-purely-ordinal-data"></a>
</h2>
<p>Our next example data set is from a survey conducted among 563
Australians in 2015 where they indicated on a scale from 1-5 how
inclined they are to take 6 types of risks. It consists of purely
ordinal variables without missing values, and the response level length
is the same for all variables. We load the data set and inspect it:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"risk"</span>, package <span class="op">=</span> <span class="st">"flexord"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html" class="external-link">str</a></span><span class="op">(</span><span class="va">risk</span><span class="op">)</span></span>
<span><span class="co">#&gt;  int [1:563, 1:6] 3 1 2 1 5 5 1 5 1 3 ...</span></span>
<span><span class="co">#&gt;  - attr(*, "dimnames")=List of 2</span></span>
<span><span class="co">#&gt;   ..$ : NULL</span></span>
<span><span class="co">#&gt;   ..$ : chr [1:6] "Recreational" "Health" "Career" "Financial" ...</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">risk</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Recreational" "Health"       "Career"       "Financial"    "Safety"      </span></span>
<span><span class="co">#&gt; [6] "Social"</span></span></code></pre></div>
<div class="section level3">
<h3 id="partitioning-approach-1">Partitioning approach<a class="anchor" aria-label="anchor" href="#partitioning-approach-1"></a>
</h3>
<p>In our package, we offer two partitioning methods designed for
ordinal data based on either Gower’s distance or GDM2 distance.</p>
<p>Applying Gower’s distance as implemented in <code>distGower</code> to
purely ordinal data corresponds to using Manhattan distance (as provided
also in <code><a href="https://rdrr.io/pkg/flexclust/man/distances.html" class="external-link">flexclust::distManhattan</a></code>) with previous scaling as
described by <span class="citation">Kaufman and Rousseeuw (1990)</span>
and Gower’s upweighing of non-missing values. The clustering can be
performed using:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/flexclust/man/kcca.html" class="external-link">kcca</a></span><span class="op">(</span><span class="va">risk</span>, k <span class="op">=</span> <span class="fl">3</span>, family <span class="op">=</span> <span class="fu"><a href="../reference/kccaExtendedFamily.html">kccaExtendedFamily</a></span><span class="op">(</span><span class="st">'kGower'</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; kcca object of family 'kGower' </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; call:</span></span>
<span><span class="co">#&gt; kcca(x = risk, k = 3, family = kccaExtendedFamily("kGower"))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; cluster sizes:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   1   2   3 </span></span>
<span><span class="co">#&gt; 161 131 271</span></span></code></pre></div>
<p>The default centroid for this family is the general purpose optimizer
<code>centOptimNA</code>, which is the general purpose optimizer
<code><a href="https://rdrr.io/pkg/flexclust/man/distances.html" class="external-link">flexclust::centOptim</a></code>, just with NA removal. In our case of
purely ordinal data with no missing values, we could also choose the
median as a centroid:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/flexclust/man/kcca.html" class="external-link">kcca</a></span><span class="op">(</span><span class="va">risk</span>, k <span class="op">=</span> <span class="fl">3</span>,</span>
<span>     family <span class="op">=</span> <span class="fu"><a href="../reference/kccaExtendedFamily.html">kccaExtendedFamily</a></span><span class="op">(</span><span class="st">'kGower'</span>, cent <span class="op">=</span> <span class="va">centMedian</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; kcca object of family 'kGower' </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; call:</span></span>
<span><span class="co">#&gt; kcca(x = risk, k = 3, family = kccaExtendedFamily("kGower", cent = centMedian))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; cluster sizes:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   1   2   3 </span></span>
<span><span class="co">#&gt; 303 160 100</span></span></code></pre></div>
<p>This results in kMedians with previous scaling, and non-missing value
upweighing. In our <code>risk</code> example with no NAs and equal
response level lengths for all variables,
<code>flexclust::kccaFamily('kmedians')</code> would suffice, but there
are still many data situations where the <code>"kGower"</code> approach
will be preferable.</p>
<p>As a second alternative designed specifically for ordinal data
without missing values, we implement the GDM2 distance for ordinal data
suggested by <span class="citation">Walesiak and Dudek (2010)</span>,
which conducts only relational operations on ordinal variables. We
reformulated this distance for use in K-centroids clustering in <span class="citation">Ernst et al. (2025)</span>, and implemented it in the
package such that one can use it for clustering via:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/flexclust/man/kcca.html" class="external-link">kcca</a></span><span class="op">(</span><span class="va">risk</span>, k <span class="op">=</span> <span class="fl">3</span>, family <span class="op">=</span> <span class="fu"><a href="../reference/kccaExtendedFamily.html">kccaExtendedFamily</a></span><span class="op">(</span><span class="st">'kGDM2'</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; kcca object of family 'kGDM2' </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; call:</span></span>
<span><span class="co">#&gt; kcca(x = risk, k = 3, family = kccaExtendedFamily("kGDM2"))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; cluster sizes:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   1   2   3 </span></span>
<span><span class="co">#&gt; 342  97 124</span></span></code></pre></div>
<p>Similar to <code>"kGower"</code>, a default general optimizer
centroid is applied, which we could replace as desired.</p>
<p>Another parameter used in both <code>"kGower"</code> and
<code>"kGDM2"</code> is <code>xrange</code>. Both algorithms require
information on the range of the variables of the data object for data
pre-processing: <code>"kGower"</code> uses this for scaling, while
<code>"kGDM2"</code> for transforming the data to empirical
distributions. The range calculation can be influenced in the following
ways: We can use the range of the whole <code>x</code> (argument
<code>all</code>, the default for <code>"kGDM2"</code>), columnwise
ranges (<code>xrange = "columnwise"</code>), a vector specifying the
range across all variables in the data set, or a list of length
<code>ncol(x)</code> with range vectors for each column. Let us assume
that the highest possible response to the <code>risk</code> questions
was <code>Extremely often (6)</code>, but it was never chosen by any of
the respondents. We can take the new assumed full range of the data into
account:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/flexclust/man/kcca.html" class="external-link">kcca</a></span><span class="op">(</span><span class="va">risk</span>, k <span class="op">=</span> <span class="fl">3</span>,</span>
<span>     family <span class="op">=</span> <span class="fu"><a href="../reference/kccaExtendedFamily.html">kccaExtendedFamily</a></span><span class="op">(</span><span class="st">'kGDM2'</span>, xrange <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">6</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; kcca object of family 'kGDM2' </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; call:</span></span>
<span><span class="co">#&gt; kcca(x = risk, k = 3, family = kccaExtendedFamily("kGDM2", xrange = c(1, </span></span>
<span><span class="co">#&gt;     6)))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; cluster sizes:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   1   2   3 </span></span>
<span><span class="co">#&gt; 117  97 349</span></span></code></pre></div>
<p>Again, the distances, centroids, and wrapper alternatives presented
can be used also in the further capabilities of
<strong>flexclust</strong>.</p>
</div>
<div class="section level3">
<h3 id="model-based-approach-1">Model-based approach<a class="anchor" aria-label="anchor" href="#model-based-approach-1"></a>
</h3>
<p>We also offer model drivers for two component distributions suitable
for ordinal data, which are the binomial distribution and its extension
the beta-binomial distribution:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">risk1</span> <span class="op">&lt;-</span> <span class="va">risk</span> <span class="op">-</span> <span class="fl">1</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/flexmix/man/flexmix.html" class="external-link">flexmix</a></span><span class="op">(</span><span class="va">risk1</span> <span class="op">~</span> <span class="fl">1</span>, k <span class="op">=</span> <span class="fl">3</span>, model <span class="op">=</span> <span class="fu"><a href="../reference/FLXMCregbinom.html">FLXMCregbinom</a></span><span class="op">(</span>size <span class="op">=</span> <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; flexmix(formula = risk1 ~ 1, k = 3, model = FLXMCregbinom(size = 4))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Cluster sizes:</span></span>
<span><span class="co">#&gt;   1   2   3 </span></span>
<span><span class="co">#&gt;  43 401 119 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; convergence after 69 iterations</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/flexmix/man/flexmix.html" class="external-link">flexmix</a></span><span class="op">(</span><span class="va">risk1</span> <span class="op">~</span> <span class="fl">1</span>, k <span class="op">=</span> <span class="fl">3</span>, model <span class="op">=</span> <span class="fu"><a href="../reference/FLXMCregbetabinom.html">FLXMCregbetabinom</a></span><span class="op">(</span>size <span class="op">=</span> <span class="fl">4</span>, alpha <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; flexmix(formula = risk1 ~ 1, k = 3, model = FLXMCregbetabinom(size = 4, </span></span>
<span><span class="co">#&gt;     alpha = 1))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Cluster sizes:</span></span>
<span><span class="co">#&gt;   1   2   3 </span></span>
<span><span class="co">#&gt;  49 108 406 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; convergence after 89 iterations</span></span></code></pre></div>
<p>In both cases we specify the number of trials of the binomial
distribution (<code>size</code>). For both distributions we can also use
a regularization parameter <code>alpha</code> that shrinkgs the
component estimates towards the population mean. While this incurs small
distortions it can be helpful to avoid boundary estimates.</p>
<p>The beta-binomial distribution is parameterized by two parameters
<code>a</code> and <code>b</code> and is therefore more flexible than
the binomial. It may potentially perform better in more difficult
clustering scenarios even if we assume the original data was drawn from
a binomial mixture <span class="citation">(Ernst et al. 2025)</span>.
Your mileage may vary.</p>
<p>We can further use the capabilities of <code>stepFlexmix</code> and
the corresponding plot functions.</p>
</div>
<div class="section level3">
<h3 id="treating-the-data-as-purely-nominal">Treating the data as purely nominal<a class="anchor" aria-label="anchor" href="#treating-the-data-as-purely-nominal"></a>
</h3>
<p>Treating ordered categorical data as unordered is a frequent
approach. In fact, in our simulation study it was a quite competitive
approach for model-based methods. However, applying <code>kmodes</code>
to ordered data brought subpar results in the partitioning ambit <span class="citation">(Ernst et al. 2025)</span>.</p>
</div>
<div class="section level3">
<h3 id="treating-the-data-as-equidistant-integer">Treating the data as equidistant (=integer)<a class="anchor" aria-label="anchor" href="#treating-the-data-as-equidistant-integer"></a>
</h3>
<p>Also treating ordered categorical data as integer values is at least
as common as nominalization. In fact, some of the methods presented
above, such as <code>"kGower"</code> - as used above on purely ordinal
data without missing values - make only lax concessions towards
ordinality. Depending on data characteristics and specific method
applied, this approach may also be a very good choice <span class="citation">(Ernst et al. 2025)</span>.</p>
<p>We do not offer any new methods for this in the partitioning ambit,
as already many options are available in <strong>flexclust</strong>. In
the model-based ambit we offer additional capabilities via
<code>FLXMCregnorm</code>, which, as mentioned, is a driver for
clustering with multivariate normal distributions (assuming conditional
independence) while allowing for regularization (as in the case for
<code>FLXMCregmultinom</code> to help avoid degenerate solutions). One
can proceed as follows to use the data-driven default regularization
parameters as proposed by <span class="citation">Fraley and Raftery
(2007)</span>:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">params</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/FLXMCregnorm_defaults.html">FLXMCregnorm_defaults</a></span><span class="op">(</span><span class="va">risk</span>, kappa_p <span class="op">=</span> <span class="fl">0.1</span>, k <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/flexmix/man/flexmix.html" class="external-link">flexmix</a></span><span class="op">(</span><span class="va">risk</span> <span class="op">~</span> <span class="fl">1</span>, k <span class="op">=</span> <span class="fl">3</span>, model <span class="op">=</span> <span class="fu"><a href="../reference/FLXMCregnorm.html">FLXMCregnorm</a></span><span class="op">(</span>params <span class="op">=</span> <span class="va">params</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; flexmix(formula = risk ~ 1, k = 3, model = FLXMCregnorm(params = params))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Cluster sizes:</span></span>
<span><span class="co">#&gt;   1   2 </span></span>
<span><span class="co">#&gt;  58 505 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; convergence after 51 iterations</span></span></code></pre></div>
<p>For details on the parameters used for regularization, see <span class="citation">Fraley and Raftery (2007)</span> or package
<strong>mclust</strong>. Here, we would only like to point out that the
shrinkage parameter <code>kappa_p</code> (the suffix <code>_p</code>
stands for prior), acts as if we added <code>kappa_p</code> observations
according to the population mean to each component. Using
<code>FLXMCregnorm_defaults</code> with the data and the number of
components determines the scale parameter <code>zeta_p</code> by
dividing the empirical variance by the square of the number of
components. Thus we need to pass the data and <code>k = 3</code>.
Alternatively, we could also specify a value for <code>zeta_p</code> and
then omit the parameter <code>k</code>. Note that we cannot set both
parameters at the same time and therefore, <code>zeta_p</code> takes
precedence if both are given.</p>
<p>Again, the model can be plugged into all of the further tools offered
by <strong>flexmix</strong>.</p>
</div>
</div>
<div class="section level2">
<h2 id="example-3-clustering-mixed-type-data-with-missing-values">Example 3: Clustering mixed-type data with missing values<a class="anchor" aria-label="anchor" href="#example-3-clustering-mixed-type-data-with-missing-values"></a>
</h2>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"vacmot"</span>, package <span class="op">=</span> <span class="st">"flexclust"</span><span class="op">)</span></span>
<span><span class="va">vacmot2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">vacmotdesc</span>,</span>
<span>                 <span class="fu"><a href="https://rdrr.io/r/base/apply.html" class="external-link">apply</a></span><span class="op">(</span><span class="va">vacmot</span>, <span class="fl">2</span>, <span class="va">as.logical</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">vacmot2</span> <span class="op">&lt;-</span> <span class="va">vacmot2</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'Gender'</span>, <span class="st">'Age'</span>, <span class="st">'Income2'</span>, <span class="st">'Relationship.Status'</span>, <span class="st">'Vacation.Behaviour'</span>,</span>
<span>                       <span class="fu"><a href="https://rdrr.io/r/base/sample.html" class="external-link">sample</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">vacmot</span><span class="op">)</span>, <span class="fl">3</span>, replace <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="va">vacmot2</span><span class="op">$</span><span class="va">Income2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">as.ordered</a></span><span class="op">(</span><span class="va">vacmot2</span><span class="op">$</span><span class="va">Income2</span><span class="op">)</span> </span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/str.html" class="external-link">str</a></span><span class="op">(</span><span class="va">vacmot2</span><span class="op">)</span></span>
<span><span class="co">#&gt; 'data.frame':    1000 obs. of  8 variables:</span></span>
<span><span class="co">#&gt;  $ Gender                  : Factor w/ 2 levels "Male","Female": 2 2 1 2 1 2 1 1 2 2 ...</span></span>
<span><span class="co">#&gt;  $ Age                     : num  25 31 21 18 61 63 58 41 36 56 ...</span></span>
<span><span class="co">#&gt;  $ Income2                 : Ord.factor w/ 5 levels "&lt;30k"&lt;"30-60k"&lt;..: 2 5 4 2 1 2 1 2 4 2 ...</span></span>
<span><span class="co">#&gt;  $ Relationship.Status     : Factor w/ 5 levels "single","married",..: 1 2 1 1 2 2 3 4 3 2 ...</span></span>
<span><span class="co">#&gt;  $ Vacation.Behaviour      : num  2.07 2 1.23 2.17 1.72 ...</span></span>
<span><span class="co">#&gt;  $ realise creativity      : logi  FALSE FALSE FALSE FALSE FALSE FALSE ...</span></span>
<span><span class="co">#&gt;  $ rest and relax          : logi  TRUE TRUE TRUE TRUE TRUE TRUE ...</span></span>
<span><span class="co">#&gt;  $ entertainment facilities: logi  FALSE FALSE FALSE TRUE FALSE FALSE ...</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colMeans</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">vacmot2</span><span class="op">)</span><span class="op">)</span><span class="op">*</span><span class="fl">100</span> </span>
<span><span class="co">#&gt;                   Gender                      Age                  Income2 </span></span>
<span><span class="co">#&gt;                      0.0                      0.0                      6.6 </span></span>
<span><span class="co">#&gt;      Relationship.Status       Vacation.Behaviour       realise creativity </span></span>
<span><span class="co">#&gt;                      0.4                      2.5                      0.0 </span></span>
<span><span class="co">#&gt;           rest and relax entertainment facilities </span></span>
<span><span class="co">#&gt;                      0.0                      0.0</span></span></code></pre></div>
<p>For our last example, we use a data set which is obtained by merging
two data sets shared in package <strong>flexclust</strong>.
<strong>flexclust</strong> provides object <code>vacmot</code>
consisting of a <span class="math inline">\(1000 \times 20\)</span>
matrix of binary responses to questions on travel motives asked
Australian tourists in 2006, plus a separate data frame
<code>vacmotdesc</code> with 12 demographic variables for each
respondent.</p>
<p>This data set has been thoroughly explored using clustering methods
in the field of market segmentation research, see for example <span class="citation">Dolnicar and Leisch (2008)</span>. We now use it as a
data example for a mixed-data case with a moderate amount of
missingness. For this, we select one symmetric binary variable (Gender,
which was collected as Male/Female in 2006), two numeric variables (Age
and Vacation Behaviour<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>), one unordered categorical variable
(Relationship Status), one ordered categorical variable (Income2, which
is a recoding of <code>Income</code>), and three randomly selected
asymmetric binary variables (3 of the 20 questions on whether a specific
travel motive applies to a respondent). Missing values are present, but
the percentage is low<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>.</p>
<div class="section level3">
<h3 id="partitioning-approach-2">Partitioning approach<a class="anchor" aria-label="anchor" href="#partitioning-approach-2"></a>
</h3>
<p>Currently, we only offer one method for mixed-type data with missing
values, which is <code>"kGower"</code> (scaling and distances as
proposed by <span class="citation">Gower (1971)</span> and <span class="citation">Kaufman and Rousseeuw (1990)</span>, and a general
purpose optimizer centroid as provided in <strong>flexclust</strong>,
but with NA omission):</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/pkg/flexclust/man/kcca.html" class="external-link">kcca</a></span><span class="op">(</span><span class="va">vacmot2</span>, k <span class="op">=</span> <span class="fl">3</span>, family <span class="op">=</span> <span class="fu"><a href="../reference/kccaExtendedFamily.html">kccaExtendedFamily</a></span><span class="op">(</span><span class="st">'kGower'</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; kcca object of family 'kGower' </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; call:</span></span>
<span><span class="co">#&gt; kcca(x = vacmot2, k = 3, family = kccaExtendedFamily("kGower"))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; cluster sizes:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   1   2   3 </span></span>
<span><span class="co">#&gt; 535  92 373</span></span></code></pre></div>
<p>In our example above, the default methods for each variable type are
used (Simple Matching Distance for the categorical variables, squared
Euclidean distance for the numerical/integer variables, Manhattan
distance for ordinal variables, and Jaccard distance for logical
variables).</p>
<p>We could instead provide a vector of length
<code>ncol(vacmot2)</code> where each distance measure to be used is
specified. Let us assume that we have many outliers in the variable
<code>Age</code>, that we woud like to consider
<code>Vacation.Behaviour</code> an ordered factor as well in addition to
<code>Income2</code>, and that the three binary responses to vacation
motives should be treated symmetric instead of asymmetric<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>, and for this reason
want to evaluate the first three with Manhattan distance, and the latter
three with Euclidean distance<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">vacmot2</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] "Gender"                   "Age"                     </span></span>
<span><span class="co">#&gt; [3] "Income2"                  "Relationship.Status"     </span></span>
<span><span class="co">#&gt; [5] "Vacation.Behaviour"       "realise creativity"      </span></span>
<span><span class="co">#&gt; [7] "rest and relax"           "entertainment facilities"</span></span>
<span><span class="va">xmthds</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">'distSimMatch'</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="st">'distManhattan'</span>, <span class="fl">3</span><span class="op">)</span>,</span>
<span>            <span class="st">'distSimMatch'</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="st">'distEuclidean'</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/flexclust/man/kcca.html" class="external-link">kcca</a></span><span class="op">(</span><span class="va">vacmot2</span>, k <span class="op">=</span> <span class="fl">3</span>,</span>
<span>     family <span class="op">=</span> <span class="fu"><a href="../reference/kccaExtendedFamily.html">kccaExtendedFamily</a></span><span class="op">(</span><span class="st">'kGower'</span>, xmethods <span class="op">=</span> <span class="va">xmthds</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; kcca object of family 'kGower' </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; call:</span></span>
<span><span class="co">#&gt; kcca(x = vacmot2, k = 3, family = kccaExtendedFamily("kGower", </span></span>
<span><span class="co">#&gt;     xmethods = xmthds))</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; cluster sizes:</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt;   1   2 </span></span>
<span><span class="co">#&gt; 488 512</span></span></code></pre></div>
<p>For <code>"kGower"</code>, all numeric/integer and ordered variables
are scaled as proposed by <span class="citation">Kaufman and Rousseeuw
(1990)</span>, by shifting by the minimum and dividing by the range.
This means that also for <code>"kGower"</code>, the range of the
variables will influence the clustering results. Same as for
<code>"kGDM2"</code> (<strong>Example 2</strong>), we can specify the
range to be used in parameter <code>xrange</code>. In the case of
<code>"kGower"</code>, the default value is <code>"columnwise"</code>,
where the range for each column is calculated separately.</p>
<p>Again, the distance, centroid and wrapper functions can be used in
the further tools provided by <strong>flexclust</strong>, for examples
on that see <strong>Example 1</strong>.</p>
</div>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-dolnicar_market_2018" class="csl-entry">
Dolnicar, Sara, Bettina Grün, and Friedrich Leisch. 2018. <em>Market
Segmentation Analysis</em>. Management for Professionals. Singapore:
Springer-Verlag. <a href="https://doi.org/10.1007/978-981-10-8818-6_2" class="external-link">https://doi.org/10.1007/978-981-10-8818-6_2</a>.
</div>
<div id="ref-dolnicar_investigation_2008" class="csl-entry">
Dolnicar, Sara, and Friedrich Leisch. 2008. <span>“An Investigation of
Tourists’ Patterns of Obligation to Protect the Environment.”</span>
<em>Journal of Travel Research</em> 46 (4): 381–91. <a href="https://doi.org/10.1177/0047287507308330" class="external-link">https://doi.org/10.1177/0047287507308330</a>.
</div>
<div id="ref-ernst_ordinal_2025" class="csl-entry">
Ernst, Dominik, Lena Ortega Menjivar, Theresa Scharl, and Bettina Grün.
2025. <span>“Ordinal Clustering with the Flex-Scheme.”</span>
<em>Austrian Journal of Statistics</em>.
</div>
<div id="ref-fraley2007bayesian" class="csl-entry">
Fraley, Chris, and Adrian E Raftery. 2007. <span>“Bayesian
Regularization for Normal Mixture Estimation and Model-Based
Clustering.”</span> <em>Journal of Classification</em> 24 (2): 155–81.
<a href="https://doi.org/10.1007/s00357-007-0004-5" class="external-link">https://doi.org/10.1007/s00357-007-0004-5</a>.
</div>
<div id="ref-galindo2006avoiding" class="csl-entry">
Galindo Garre, Francisca, and Jeroen K Vermunt. 2006. <span>“Avoiding
Boundary Estimates in Latent Class Analysis by <span>B</span>ayesian
Posterior Mode Estimation.”</span> <em>Behaviormetrika</em> 33: 43–59.
<a href="https://doi.org/10.2333/bhmk.33.43" class="external-link">https://doi.org/10.2333/bhmk.33.43</a>.
</div>
<div id="ref-gower_1971" class="csl-entry">
Gower, J. C. 1971. <span>“A General Coefficient of Similarity and Some
of Its Properties.”</span> <em>Biometrics</em> 27 (4): 857–71. <a href="https://doi.org/10.2307/2528823" class="external-link">https://doi.org/10.2307/2528823</a>.
</div>
<div id="ref-hubert_arabie_1985" class="csl-entry">
Hubert, Lawrence, and Phipps Arabie. 1985. <span>“Comparing
Partitions.”</span> <em>Journal of Classification</em> 2 (1): 193–218.
<a href="https://doi.org/10.1007/BF01908075" class="external-link">https://doi.org/10.1007/BF01908075</a>.
</div>
<div id="ref-kaufman_finding_1990" class="csl-entry">
Kaufman, Leonard, and Peter Rousseeuw. 1990. <em>Finding Groups in Data:
An Introduction to Cluster Analysis</em>. Wiley Series in Probability
and Statistics. New York: John Wiley &amp; Sons. <a href="https://doi.org/10.1002/9780470316801" class="external-link">https://doi.org/10.1002/9780470316801</a>.
</div>
<div id="ref-kondofersky2008" class="csl-entry">
Kondofersky, Ivan. 2008. <span>“Modellbasiertes Clustern <span class="nocase">mit</span> Der Beta-Binomialverteilung.”</span>
Bachelor's Thesis.
</div>
<div id="ref-leisch_toolbox_2006" class="csl-entry">
Leisch, Friedrich. 2006. <span>“A Toolbox for <span>K</span>-Centroids
Cluster Analysis.”</span> <em>Computational Statistics &amp; Data
Analysis</em> 51 (2): 526–44. <a href="https://doi.org/10.1016/j.csda.2005.10.006" class="external-link">https://doi.org/10.1016/j.csda.2005.10.006</a>.
</div>
<div id="ref-walesiak_finding_2010" class="csl-entry">
Walesiak, Marek, and Andrzej Dudek. 2010. <span>“Finding Groups in
Ordinal Data: An Examination of Some Clustering Procedures.”</span> In
<em>Classification as a Tool for Research</em>, edited by Hermann
Locarek-Junge and Claus Weihs, 185–92. Berlin, Heidelberg:
Springer-Verlag. <a href="https://doi.org/10.1007/978-3-642-10745-0_19" class="external-link">https://doi.org/10.1007/978-3-642-10745-0_19</a>.
</div>
<div id="ref-weihs_klaR_2005" class="csl-entry">
Weihs, Claus, Uwe Ligges, Karsten Luebke, and Nils Raabe. 2005.
<span>“<span class="nocase">klaR</span> Analyzing <span>G</span>erman
Business Cycles.”</span> In <em>Data Analysis and Decision Support</em>,
edited by Daniel Baier, Reinhold Decker, and Lars Schmidt-Thieme,
335–43. Berlin: Springer-Verlag. <a href="https://doi.org/10.1007/3-540-28397-8_36" class="external-link">https://doi.org/10.1007/3-540-28397-8_36</a>.
</div>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>Internally, it will be converted to a
<code>data.matrix</code>. However, as only equality operations and
frequency counts are used, this is of no consequence.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>I.e., the mean disagreement count.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>Mean environmental friendly behavior score, ranging from
1 to 5.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>This is by choice. While Gower’s distance is designed to
handle missingness via variable weighting, and the general optimizer
used here is written to omit NAs, both methods will degenerate with high
percentages of missing values. While we have not yet determined the
critical limit, we have successfully run the algorithm on purely ordinal
data with MCAR missingness percentages of up to 30%. However, common
sense dictates that solutions obtained for such high missingness
percentages need to be treated with caution.<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>Meaning that 2 disagreements are just as important as 2
agreements.<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>We could achieve symmetric treatment also via Simple
Matching Distance.<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Lena Ortega Menjivar, Dominik Ernst.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.9.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
